package container

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"strings"

	. "github.com/gooff/di/container/utilsast"
)

func NewBuilder() *Builder {
	return &Builder{
		definitions: map[string]*Definition{},
		fset:        token.NewFileSet(),
	}
}

type Builder struct {
	aliases     map[string]string
	parameters  map[string]interface{}
	definitions map[string]*Definition

	fset     *token.FileSet
	file     *ast.File
}

func (b *Builder) AddAlias(alias string, service string) {
	b.aliases[alias] = service
}

func (b *Builder) RemoveAlias(alias string) {
	delete(b.aliases, alias)
}

func (b *Builder) GetAliases() map[string]string {
	return b.aliases
}

func (b *Builder) AddDefinition(name string) *Definition {
	name = b.resolveName(name)

	if b.HasDefinition(name) {
		log.Fatalln("Service", name, "already registered")
	}
	for n, _ := range b.definitions {
		if strings.ToLower(n) == strings.ToLower(name) {
			log.Fatalln("Service", name, "already registered in a case-insensitive manner")
		}
	}

	def := NewServiceDefinition()
	def.SetName(name)
	b.definitions[name] = def

	return def
}

func (b *Builder) RemoveDefinition(name string) {
	delete(b.definitions, b.resolveName(name))
}

func (b *Builder) GetDefinition(name string) *Definition {
	return b.definitions[b.resolveName(name)]
}

func (b *Builder) HasDefinition(name string) bool {
	_, ok := b.definitions[b.resolveName(name)]
	return ok
}

func (b *Builder) resolveName(name string) string {
	if alias, ok := b.aliases[name]; ok {
		return alias
	}
	return name
}

func (b *Builder) Build(packageName string, outputFile string) error {
	var err error
	packageLine := fmt.Sprintf("// Generated by gooff/di; DO NOT EDIT\npackage %s", packageName)

	b.file, err = parser.ParseFile(b.fset, outputFile, packageLine, parser.ParseComments)
	if err != nil {
		return err
	}

	outFile, err := os.Create(outputFile)
	if err != nil {
		return err
	}

	tree, paths := prepareTree(b.definitions)
	b.file.Decls = append(b.file.Decls, b.astBlocks(tree)...)
	b.file.Decls = append(b.file.Decls, b.astGetMethods(tree, paths)...)

	b.file.Decls = append(b.file.Decls,
		b.astNewContainerFunc(),
		b.astDefaultContainer(),
	)

	ast.SortImports(b.fset, b.file)

	return printer.Fprint(outFile, b.fset, b.file)
}

// func (b *Builder) astContainerStruct() ast.Decl {
// 	var containerFields []*ast.Field
//
// 	for name, def := range b.definitions {
// 		log.Println("Create container field", name)
// 		containerFields = append(containerFields, &ast.Field{
// 			Names: []*ast.Ident{
// 				NewIdent(strings.Replace(name, ".", "_", -1)),
// 			},
// 			Type: def.astContainerFieldType(b),
// 		})
// 	}
//
// 	return &ast.GenDecl{
// 		Tok: token.TYPE,
// 		Specs: []ast.Spec{
// 			&ast.TypeSpec{
// 				Name: NewIdent("Container"),
// 				Type: &ast.StructType{
// 					Fields: &ast.FieldList{
// 						List: containerFields,
// 					},
// 				},
// 			},
// 		},
// 	}
// }

func (b *Builder) astDefaultContainer() *ast.GenDecl {
	return NewVar("DefaultContainer", "NewContainer()")
}
