package container

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"strings"

	"github.com/gooff/di/utils/shortcut"
)

func NewBuilder() *Builder {
	return &Builder{
		definitions: map[string]*Definition{},
		fset:        token.NewFileSet(),
	}
}

type Builder struct {
	aliases     map[string]string
	parameters  map[string]interface{}
	definitions map[string]*Definition

	fset     *token.FileSet
	file     *ast.File
}

func (b *Builder) AddAlias(alias string, service string) {
	b.aliases[alias] = service
}

func (b *Builder) RemoveAlias(alias string) {
	delete(b.aliases, alias)
}

func (b *Builder) GetAliases() map[string]string {
	return b.aliases
}

func (b *Builder) AddDefinition(name string) (*Definition, error) {
	name = b.resolveName(name)

	if b.HasDefinition(name) {
		return nil, fmt.Errorf("service '%s' already registered", name)
	}
	for n, _ := range b.definitions {
		if strings.ToLower(n) == strings.ToLower(name) {
			return nil, fmt.Errorf("service '%s' already registered in a case-insensitive manner", name)
		}
	}

	def := NewServiceDefinition()
	def.SetName(name)
	b.definitions[name] = def

	return def, nil
}

func (b *Builder) MustAddDefinition(name string) *Definition {
	def, err := b.AddDefinition(name)
	if err != nil {
		panic(err)
	}
	return def
}

func (b *Builder) RemoveDefinition(name string) {
	delete(b.definitions, b.resolveName(name))
}

func (b *Builder) GetDefinition(name string) *Definition {
	return b.definitions[b.resolveName(name)]
}

func (b *Builder) HasDefinition(name string) bool {
	_, ok := b.definitions[b.resolveName(name)]
	return ok
}

func (b *Builder) resolveName(name string) string {
	if alias, ok := b.aliases[name]; ok {
		return alias
	}
	return name
}

func (b *Builder) Build(packageName string, outputFile string) error {
	var err error
	packageLine := fmt.Sprintf("// Generated by gooff/di; DO NOT EDIT\npackage %s", packageName)

	b.file, err = parser.ParseFile(b.fset, outputFile, packageLine, parser.ParseComments)
	if err != nil {
		return err
	}

	outFile, err := os.Create(outputFile)
	if err != nil {
		return err
	}

	tree, paths := prepareTree(b.definitions)
	b.file.Decls = append(b.file.Decls, b.astBlocks(tree)...)
	b.file.Decls = append(b.file.Decls, b.astGetMethods(tree, paths)...)

	b.file.Decls = append(b.file.Decls,
		b.astNewContainerFunc(),
		b.astDefaultContainer(),
	)

	ast.SortImports(b.fset, b.file)

	return printer.Fprint(outFile, b.fset, b.file)
}

func (b *Builder) astDefaultContainer() *ast.GenDecl {
	return shortcut.NewVar("DefaultContainer", "NewContainer()")
}
